import os

from data import common

import numpy as np
import scipy.misc as misc

import torch
import torch.utils.data as data

class LRHRDataset(data.Dataset):
    def name(self):
        return 'LRHRDataset'

    def __init__(self, opt):
        super(LRHRDataset, self).__init__()
        # self.args = args
        self.opt = opt

        self.train = (opt['phase'] == 'train')
        self.split = 'train' if self.train else 'test'

        self.repeat = 1

        # TODO
        # self.benchmark = benchmark

        self.scale = self.opt['scale']
        self.idx_scale = 0

        # read image list from lmdb or image files
        self.HR_env, self.paths_HR = common.get_image_paths(self.opt['data_type'], self.opt['dataroot_HR'])
        self.LR_env, self.paths_LR = common.get_image_paths(self.opt['data_type'], self.opt['dataroot_LR'])

        assert self.paths_HR, 'Error: HR paths are empty.'
        if self.paths_LR and self.paths_HR:
            assert len(self.paths_LR) == len(self.paths_HR), \
                'HR and LR datasets have different number of images - {}, {}.'.format(\
                len(self.paths_LR), len(self.paths_HR))

        # TODO: random_scale
        # self.random_scale_list = [1, 0.9, 0.8, 0.7, 0.6, 0.5]
        self.random_scale_list = None

    def __getitem__(self, idx):
        lr, hr, lr_path, hr_path = self._load_file(idx)
        lr, hr = self._get_patch(lr, hr)
        # channel conversion
        if self.opt['color']:
            lr, hr = common.channel_convert(hr.shape[2], [lr, hr], self.opt['color'])
        lr_tensor, hr_tensor = common.np2Tensor([lr, hr], self.opt['rgb_range'])
        return {'LR': lr_tensor, 'HR': hr_tensor, 'LR_path': lr_path, 'HR_path': hr_path}

    def __len__(self):
        if self.train:
            return len(self.paths_HR) * self.repeat
        else:
            return len(self.paths_LR)

    def _get_index(self, idx):
        if self.train:
            return idx % len(self.paths_HR)
        else:
            return idx

    def _load_file(self, idx):
        idx = self._get_index(idx)
        lr_path = self.paths_LR[idx]
        hr_path = self.paths_HR[idx]
        lr = common.read_img(self.LR_env, lr_path, self.opt['data_type'])
        hr = common.read_img(self.HR_env, hr_path, self.opt['data_type'])

        return lr, hr, lr_path, hr_path

    def _get_patch(self, lr, hr):
        LR_size = self.opt['LR_size']
        if self.train:
            lr, hr = common.get_patch(
                lr, hr, LR_size, self.scale)
            lr, hr = common.augment([lr, hr])
            lr = common.add_noise(lr, self.opt['noise'])
        else:
            hr = common.modcrop(hr, self.scale)

        return lr, hr


